/*
 * Core API
 * Front is a customer operations platform that enables support, sales, and account management teams to deliver exceptional service at scale. Front streamlines customer communication by combining the efficiency of a help desk and the familiarity of email, with automated workflows and real-time collaboration behind the scenes.  With Front, teams can centralize messages across channels, route them to the right person, and unlock visibility and insights across all of their customer operations. More than 8000 businesses use Front to drive operational efficiency that prevents churn, improves retention, and propels customer growth.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.CreatePrivateSignature;
import com.konfigthis.client.model.CreateSharedSignature;
import com.konfigthis.client.model.SignaturesListTeammateResponse;
import com.konfigthis.client.model.UpdateSignature;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class SignaturesApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SignaturesApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public SignaturesApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createTeamSignatureCall(String teamId, CreateSharedSignature createSharedSignature, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createSharedSignature;

        // create path and map variables
        String localVarPath = "/teams/{team_id}/signatures"
            .replace("{" + "team_id" + "}", localVarApiClient.escapeString(teamId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createTeamSignatureValidateBeforeCall(String teamId, CreateSharedSignature createSharedSignature, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'teamId' is set
        if (teamId == null) {
            throw new ApiException("Missing the required parameter 'teamId' when calling createTeamSignature(Async)");
        }

        return createTeamSignatureCall(teamId, createSharedSignature, _callback);

    }


    private ApiResponse<Object> createTeamSignatureWithHttpInfo(String teamId, CreateSharedSignature createSharedSignature) throws ApiException {
        okhttp3.Call localVarCall = createTeamSignatureValidateBeforeCall(teamId, createSharedSignature, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createTeamSignatureAsync(String teamId, CreateSharedSignature createSharedSignature, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = createTeamSignatureValidateBeforeCall(teamId, createSharedSignature, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateTeamSignatureRequestBuilder {
        private final String name;
        private final String body;
        private final String teamId;
        private String senderInfo;
        private Boolean isVisibleForAllTeammateChannels;
        private Boolean isDefault;
        private List<String> channelIds;

        private CreateTeamSignatureRequestBuilder(String name, String body, String teamId) {
            this.name = name;
            this.body = body;
            this.teamId = teamId;
        }

        /**
         * Set senderInfo
         * @param senderInfo Sender info of the signature that will appear in the From line of emails sent. (optional)
         * @return CreateTeamSignatureRequestBuilder
         */
        public CreateTeamSignatureRequestBuilder senderInfo(String senderInfo) {
            this.senderInfo = senderInfo;
            return this;
        }
        
        /**
         * Set isVisibleForAllTeammateChannels
         * @param isVisibleForAllTeammateChannels Whether or not the signature is visible in all individual channels for teammates in the given team. (optional)
         * @return CreateTeamSignatureRequestBuilder
         */
        public CreateTeamSignatureRequestBuilder isVisibleForAllTeammateChannels(Boolean isVisibleForAllTeammateChannels) {
            this.isVisibleForAllTeammateChannels = isVisibleForAllTeammateChannels;
            return this;
        }
        
        /**
         * Set isDefault
         * @param isDefault If true, the signature will be set as the default signature for the team. (optional, default to false)
         * @return CreateTeamSignatureRequestBuilder
         */
        public CreateTeamSignatureRequestBuilder isDefault(Boolean isDefault) {
            this.isDefault = isDefault;
            return this;
        }
        
        /**
         * Set channelIds
         * @param channelIds The specific channels this signature is available in. If omitted or null, the signature will be available in all channels the team has access to. Alternatively, you can specify channels using a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1). (optional)
         * @return CreateTeamSignatureRequestBuilder
         */
        public CreateTeamSignatureRequestBuilder channelIds(List<String> channelIds) {
            this.channelIds = channelIds;
            return this;
        }
        
        /**
         * Build call for createTeamSignature
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            CreateSharedSignature createSharedSignature = buildBodyParams();
            return createTeamSignatureCall(teamId, createSharedSignature, _callback);
        }

        private CreateSharedSignature buildBodyParams() {
            CreateSharedSignature createSharedSignature = new CreateSharedSignature();
            createSharedSignature.name(this.name);
            createSharedSignature.senderInfo(this.senderInfo);
            createSharedSignature.body(this.body);
            createSharedSignature.isVisibleForAllTeammateChannels(this.isVisibleForAllTeammateChannels);
            createSharedSignature.isDefault(this.isDefault);
            createSharedSignature.channelIds(this.channelIds);
            return createSharedSignature;
        }

        /**
         * Execute createTeamSignature request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            CreateSharedSignature createSharedSignature = buildBodyParams();
            ApiResponse<Object> localVarResp = createTeamSignatureWithHttpInfo(teamId, createSharedSignature);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createTeamSignature request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            CreateSharedSignature createSharedSignature = buildBodyParams();
            return createTeamSignatureWithHttpInfo(teamId, createSharedSignature);
        }

        /**
         * Execute createTeamSignature request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            CreateSharedSignature createSharedSignature = buildBodyParams();
            return createTeamSignatureAsync(teamId, createSharedSignature, _callback);
        }
    }

    /**
     * Create team signature
     * Create a new signature for the given team (workspace).
     * @param teamId The team ID (required)
     * @return CreateTeamSignatureRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
     </table>
     */
    public CreateTeamSignatureRequestBuilder createTeamSignature(String name, String body, String teamId) throws IllegalArgumentException {
        if (name == null) throw new IllegalArgumentException("\"name\" is required but got null");
            

        if (body == null) throw new IllegalArgumentException("\"body\" is required but got null");
            

        if (teamId == null) throw new IllegalArgumentException("\"teamId\" is required but got null");
            

        return new CreateTeamSignatureRequestBuilder(name, body, teamId);
    }
    private okhttp3.Call createTeammateSignatureCall(String teammateId, CreatePrivateSignature createPrivateSignature, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createPrivateSignature;

        // create path and map variables
        String localVarPath = "/teammates/{teammate_id}/signatures"
            .replace("{" + "teammate_id" + "}", localVarApiClient.escapeString(teammateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createTeammateSignatureValidateBeforeCall(String teammateId, CreatePrivateSignature createPrivateSignature, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'teammateId' is set
        if (teammateId == null) {
            throw new ApiException("Missing the required parameter 'teammateId' when calling createTeammateSignature(Async)");
        }

        return createTeammateSignatureCall(teammateId, createPrivateSignature, _callback);

    }


    private ApiResponse<Object> createTeammateSignatureWithHttpInfo(String teammateId, CreatePrivateSignature createPrivateSignature) throws ApiException {
        okhttp3.Call localVarCall = createTeammateSignatureValidateBeforeCall(teammateId, createPrivateSignature, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createTeammateSignatureAsync(String teammateId, CreatePrivateSignature createPrivateSignature, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = createTeammateSignatureValidateBeforeCall(teammateId, createPrivateSignature, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateTeammateSignatureRequestBuilder {
        private final String name;
        private final String body;
        private final String teammateId;
        private String senderInfo;
        private Boolean isDefault;
        private List<String> channelIds;

        private CreateTeammateSignatureRequestBuilder(String name, String body, String teammateId) {
            this.name = name;
            this.body = body;
            this.teammateId = teammateId;
        }

        /**
         * Set senderInfo
         * @param senderInfo Sender info of the signature that will appear in the From line of emails sent. (optional)
         * @return CreateTeammateSignatureRequestBuilder
         */
        public CreateTeammateSignatureRequestBuilder senderInfo(String senderInfo) {
            this.senderInfo = senderInfo;
            return this;
        }
        
        /**
         * Set isDefault
         * @param isDefault If true, the signature will be set as the default signature for the teammate. (optional, default to false)
         * @return CreateTeammateSignatureRequestBuilder
         */
        public CreateTeammateSignatureRequestBuilder isDefault(Boolean isDefault) {
            this.isDefault = isDefault;
            return this;
        }
        
        /**
         * Set channelIds
         * @param channelIds The specific channels this signature is available in. If omitted or null, the signature will be available in all channels the teammate has access to. Alternatively, you can specify channels using a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1). (optional)
         * @return CreateTeammateSignatureRequestBuilder
         */
        public CreateTeammateSignatureRequestBuilder channelIds(List<String> channelIds) {
            this.channelIds = channelIds;
            return this;
        }
        
        /**
         * Build call for createTeammateSignature
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            CreatePrivateSignature createPrivateSignature = buildBodyParams();
            return createTeammateSignatureCall(teammateId, createPrivateSignature, _callback);
        }

        private CreatePrivateSignature buildBodyParams() {
            CreatePrivateSignature createPrivateSignature = new CreatePrivateSignature();
            createPrivateSignature.name(this.name);
            createPrivateSignature.senderInfo(this.senderInfo);
            createPrivateSignature.body(this.body);
            createPrivateSignature.isDefault(this.isDefault);
            createPrivateSignature.channelIds(this.channelIds);
            return createPrivateSignature;
        }

        /**
         * Execute createTeammateSignature request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            CreatePrivateSignature createPrivateSignature = buildBodyParams();
            ApiResponse<Object> localVarResp = createTeammateSignatureWithHttpInfo(teammateId, createPrivateSignature);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createTeammateSignature request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            CreatePrivateSignature createPrivateSignature = buildBodyParams();
            return createTeammateSignatureWithHttpInfo(teammateId, createPrivateSignature);
        }

        /**
         * Execute createTeammateSignature request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            CreatePrivateSignature createPrivateSignature = buildBodyParams();
            return createTeammateSignatureAsync(teammateId, createPrivateSignature, _callback);
        }
    }

    /**
     * Create teammate signature
     * Create a new signature for the given teammate
     * @param teammateId The teammate ID. Alternatively, you can supply an email as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1). (required)
     * @return CreateTeammateSignatureRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> A signature </td><td>  -  </td></tr>
     </table>
     */
    public CreateTeammateSignatureRequestBuilder createTeammateSignature(String name, String body, String teammateId) throws IllegalArgumentException {
        if (name == null) throw new IllegalArgumentException("\"name\" is required but got null");
            

        if (body == null) throw new IllegalArgumentException("\"body\" is required but got null");
            

        if (teammateId == null) throw new IllegalArgumentException("\"teammateId\" is required but got null");
            

        return new CreateTeammateSignatureRequestBuilder(name, body, teammateId);
    }
    private okhttp3.Call deleteSignatureCall(String signatureId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatures/{signature_id}"
            .replace("{" + "signature_id" + "}", localVarApiClient.escapeString(signatureId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteSignatureValidateBeforeCall(String signatureId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'signatureId' is set
        if (signatureId == null) {
            throw new ApiException("Missing the required parameter 'signatureId' when calling deleteSignature(Async)");
        }

        return deleteSignatureCall(signatureId, _callback);

    }


    private ApiResponse<Void> deleteSignatureWithHttpInfo(String signatureId) throws ApiException {
        okhttp3.Call localVarCall = deleteSignatureValidateBeforeCall(signatureId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteSignatureAsync(String signatureId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteSignatureValidateBeforeCall(signatureId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteSignatureRequestBuilder {
        private final String signatureId;

        private DeleteSignatureRequestBuilder(String signatureId) {
            this.signatureId = signatureId;
        }

        /**
         * Build call for deleteSignature
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteSignatureCall(signatureId, _callback);
        }


        /**
         * Execute deleteSignature request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteSignatureWithHttpInfo(signatureId);
        }

        /**
         * Execute deleteSignature request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteSignatureWithHttpInfo(signatureId);
        }

        /**
         * Execute deleteSignature request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteSignatureAsync(signatureId, _callback);
        }
    }

    /**
     * Delete signature
     * Delete signature
     * @param signatureId The signature ID (required)
     * @return DeleteSignatureRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public DeleteSignatureRequestBuilder deleteSignature(String signatureId) throws IllegalArgumentException {
        if (signatureId == null) throw new IllegalArgumentException("\"signatureId\" is required but got null");
            

        return new DeleteSignatureRequestBuilder(signatureId);
    }
    private okhttp3.Call getSignatureCall(String signatureId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/signatures/{signature_id}"
            .replace("{" + "signature_id" + "}", localVarApiClient.escapeString(signatureId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSignatureValidateBeforeCall(String signatureId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'signatureId' is set
        if (signatureId == null) {
            throw new ApiException("Missing the required parameter 'signatureId' when calling getSignature(Async)");
        }

        return getSignatureCall(signatureId, _callback);

    }


    private ApiResponse<Object> getSignatureWithHttpInfo(String signatureId) throws ApiException {
        okhttp3.Call localVarCall = getSignatureValidateBeforeCall(signatureId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getSignatureAsync(String signatureId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSignatureValidateBeforeCall(signatureId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetSignatureRequestBuilder {
        private final String signatureId;

        private GetSignatureRequestBuilder(String signatureId) {
            this.signatureId = signatureId;
        }

        /**
         * Build call for getSignature
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getSignatureCall(signatureId, _callback);
        }


        /**
         * Execute getSignature request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getSignatureWithHttpInfo(signatureId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getSignature request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getSignatureWithHttpInfo(signatureId);
        }

        /**
         * Execute getSignature request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getSignatureAsync(signatureId, _callback);
        }
    }

    /**
     * Get signatures
     * Get the given signature.
     * @param signatureId The signature ID (required)
     * @return GetSignatureRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
     </table>
     */
    public GetSignatureRequestBuilder getSignature(String signatureId) throws IllegalArgumentException {
        if (signatureId == null) throw new IllegalArgumentException("\"signatureId\" is required but got null");
            

        return new GetSignatureRequestBuilder(signatureId);
    }
    private okhttp3.Call listTeamCall(String teamId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/teams/{team_id}/signatures"
            .replace("{" + "team_id" + "}", localVarApiClient.escapeString(teamId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listTeamValidateBeforeCall(String teamId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'teamId' is set
        if (teamId == null) {
            throw new ApiException("Missing the required parameter 'teamId' when calling listTeam(Async)");
        }

        return listTeamCall(teamId, _callback);

    }


    private ApiResponse<SignaturesListTeammateResponse> listTeamWithHttpInfo(String teamId) throws ApiException {
        okhttp3.Call localVarCall = listTeamValidateBeforeCall(teamId, null);
        Type localVarReturnType = new TypeToken<SignaturesListTeammateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listTeamAsync(String teamId, final ApiCallback<SignaturesListTeammateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listTeamValidateBeforeCall(teamId, _callback);
        Type localVarReturnType = new TypeToken<SignaturesListTeammateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListTeamRequestBuilder {
        private final String teamId;

        private ListTeamRequestBuilder(String teamId) {
            this.teamId = teamId;
        }

        /**
         * Build call for listTeam
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listTeamCall(teamId, _callback);
        }


        /**
         * Execute listTeam request
         * @return SignaturesListTeammateResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
         </table>
         */
        public SignaturesListTeammateResponse execute() throws ApiException {
            ApiResponse<SignaturesListTeammateResponse> localVarResp = listTeamWithHttpInfo(teamId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listTeam request with HTTP info returned
         * @return ApiResponse&lt;SignaturesListTeammateResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SignaturesListTeammateResponse> executeWithHttpInfo() throws ApiException {
            return listTeamWithHttpInfo(teamId);
        }

        /**
         * Execute listTeam request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SignaturesListTeammateResponse> _callback) throws ApiException {
            return listTeamAsync(teamId, _callback);
        }
    }

    /**
     * List team signatures
     * List the signatures belonging to the given team (workspace).
     * @param teamId The team ID (required)
     * @return ListTeamRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
     </table>
     */
    public ListTeamRequestBuilder listTeam(String teamId) throws IllegalArgumentException {
        if (teamId == null) throw new IllegalArgumentException("\"teamId\" is required but got null");
            

        return new ListTeamRequestBuilder(teamId);
    }
    private okhttp3.Call listTeammateCall(String teammateId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/teammates/{teammate_id}/signatures"
            .replace("{" + "teammate_id" + "}", localVarApiClient.escapeString(teammateId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listTeammateValidateBeforeCall(String teammateId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'teammateId' is set
        if (teammateId == null) {
            throw new ApiException("Missing the required parameter 'teammateId' when calling listTeammate(Async)");
        }

        return listTeammateCall(teammateId, _callback);

    }


    private ApiResponse<SignaturesListTeammateResponse> listTeammateWithHttpInfo(String teammateId) throws ApiException {
        okhttp3.Call localVarCall = listTeammateValidateBeforeCall(teammateId, null);
        Type localVarReturnType = new TypeToken<SignaturesListTeammateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listTeammateAsync(String teammateId, final ApiCallback<SignaturesListTeammateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listTeammateValidateBeforeCall(teammateId, _callback);
        Type localVarReturnType = new TypeToken<SignaturesListTeammateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListTeammateRequestBuilder {
        private final String teammateId;

        private ListTeammateRequestBuilder(String teammateId) {
            this.teammateId = teammateId;
        }

        /**
         * Build call for listTeammate
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listTeammateCall(teammateId, _callback);
        }


        /**
         * Execute listTeammate request
         * @return SignaturesListTeammateResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
         </table>
         */
        public SignaturesListTeammateResponse execute() throws ApiException {
            ApiResponse<SignaturesListTeammateResponse> localVarResp = listTeammateWithHttpInfo(teammateId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listTeammate request with HTTP info returned
         * @return ApiResponse&lt;SignaturesListTeammateResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<SignaturesListTeammateResponse> executeWithHttpInfo() throws ApiException {
            return listTeammateWithHttpInfo(teammateId);
        }

        /**
         * Execute listTeammate request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<SignaturesListTeammateResponse> _callback) throws ApiException {
            return listTeammateAsync(teammateId, _callback);
        }
    }

    /**
     * List teammate signatures
     * List the signatures belonging to the given teammate.
     * @param teammateId The teammate ID. Alternatively, you can supply an email as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1). (required)
     * @return ListTeammateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Array of signatures </td><td>  -  </td></tr>
     </table>
     */
    public ListTeammateRequestBuilder listTeammate(String teammateId) throws IllegalArgumentException {
        if (teammateId == null) throw new IllegalArgumentException("\"teammateId\" is required but got null");
            

        return new ListTeammateRequestBuilder(teammateId);
    }
    private okhttp3.Call updateSignatureCall(String signatureId, UpdateSignature updateSignature, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateSignature;

        // create path and map variables
        String localVarPath = "/signatures/{signature_id}"
            .replace("{" + "signature_id" + "}", localVarApiClient.escapeString(signatureId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSignatureValidateBeforeCall(String signatureId, UpdateSignature updateSignature, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'signatureId' is set
        if (signatureId == null) {
            throw new ApiException("Missing the required parameter 'signatureId' when calling updateSignature(Async)");
        }

        return updateSignatureCall(signatureId, updateSignature, _callback);

    }


    private ApiResponse<Object> updateSignatureWithHttpInfo(String signatureId, UpdateSignature updateSignature) throws ApiException {
        okhttp3.Call localVarCall = updateSignatureValidateBeforeCall(signatureId, updateSignature, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateSignatureAsync(String signatureId, UpdateSignature updateSignature, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateSignatureValidateBeforeCall(signatureId, updateSignature, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateSignatureRequestBuilder {
        private final String signatureId;
        private String name;
        private String senderInfo;
        private String body;
        private Boolean isVisibleForAllTeammateChannels;
        private Boolean isDefault;
        private List<String> channelIds;

        private UpdateSignatureRequestBuilder(String signatureId) {
            this.signatureId = signatureId;
        }

        /**
         * Set name
         * @param name Name of the signature (optional)
         * @return UpdateSignatureRequestBuilder
         */
        public UpdateSignatureRequestBuilder name(String name) {
            this.name = name;
            return this;
        }
        
        /**
         * Set senderInfo
         * @param senderInfo Sender info of the signature that will appear in the From line of emails sent. (optional)
         * @return UpdateSignatureRequestBuilder
         */
        public UpdateSignatureRequestBuilder senderInfo(String senderInfo) {
            this.senderInfo = senderInfo;
            return this;
        }
        
        /**
         * Set body
         * @param body Body of the signature (optional)
         * @return UpdateSignatureRequestBuilder
         */
        public UpdateSignatureRequestBuilder body(String body) {
            this.body = body;
            return this;
        }
        
        /**
         * Set isVisibleForAllTeammateChannels
         * @param isVisibleForAllTeammateChannels Whether or not the signature is visible in all individual channels for teammates in the given team. Can only be set for shared signatures. (optional)
         * @return UpdateSignatureRequestBuilder
         */
        public UpdateSignatureRequestBuilder isVisibleForAllTeammateChannels(Boolean isVisibleForAllTeammateChannels) {
            this.isVisibleForAllTeammateChannels = isVisibleForAllTeammateChannels;
            return this;
        }
        
        /**
         * Set isDefault
         * @param isDefault If true, the signature will be set as the default signature for the team or teammate. (optional, default to false)
         * @return UpdateSignatureRequestBuilder
         */
        public UpdateSignatureRequestBuilder isDefault(Boolean isDefault) {
            this.isDefault = isDefault;
            return this;
        }
        
        /**
         * Set channelIds
         * @param channelIds The specific shared channels this signature if available in. If null, then it will be available in all channels. If unspecified, will retain previous value. Alternatively, you can specify channels using a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1). (optional)
         * @return UpdateSignatureRequestBuilder
         */
        public UpdateSignatureRequestBuilder channelIds(List<String> channelIds) {
            this.channelIds = channelIds;
            return this;
        }
        
        /**
         * Build call for updateSignature
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            UpdateSignature updateSignature = buildBodyParams();
            return updateSignatureCall(signatureId, updateSignature, _callback);
        }

        private UpdateSignature buildBodyParams() {
            UpdateSignature updateSignature = new UpdateSignature();
            updateSignature.name(this.name);
            updateSignature.senderInfo(this.senderInfo);
            updateSignature.body(this.body);
            updateSignature.isVisibleForAllTeammateChannels(this.isVisibleForAllTeammateChannels);
            updateSignature.isDefault(this.isDefault);
            updateSignature.channelIds(this.channelIds);
            return updateSignature;
        }

        /**
         * Execute updateSignature request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            UpdateSignature updateSignature = buildBodyParams();
            ApiResponse<Object> localVarResp = updateSignatureWithHttpInfo(signatureId, updateSignature);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute updateSignature request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            UpdateSignature updateSignature = buildBodyParams();
            return updateSignatureWithHttpInfo(signatureId, updateSignature);
        }

        /**
         * Execute updateSignature request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            UpdateSignature updateSignature = buildBodyParams();
            return updateSignatureAsync(signatureId, updateSignature, _callback);
        }
    }

    /**
     * Update signature
     * Update signature
     * @param signatureId The signature ID (required)
     * @return UpdateSignatureRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A signature </td><td>  -  </td></tr>
     </table>
     */
    public UpdateSignatureRequestBuilder updateSignature(String signatureId) throws IllegalArgumentException {
        if (signatureId == null) throw new IllegalArgumentException("\"signatureId\" is required but got null");
            

        return new UpdateSignatureRequestBuilder(signatureId);
    }
}
