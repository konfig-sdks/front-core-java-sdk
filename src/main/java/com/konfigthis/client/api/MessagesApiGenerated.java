/*
 * Core API
 * Front is a customer operations platform that enables support, sales, and account management teams to deliver exceptional service at scale. Front streamlines customer communication by combining the efficiency of a help desk and the familiarity of email, with automated workflows and real-time collaboration behind the scenes.  With Front, teams can centralize messages across channels, route them to the right person, and unlock visibility and insights across all of their customer operations. More than 8000 businesses use Front to drive operational efficiency that prevents churn, improves retention, and propels customer growth.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.CustomMessage;
import com.konfigthis.client.model.CustomMessageMetadata;
import com.konfigthis.client.model.CustomMessageSender;
import java.io.File;
import com.konfigthis.client.model.ImportMessage;
import com.konfigthis.client.model.ImportMessageMetadata;
import com.konfigthis.client.model.ImportMessageSender;
import com.konfigthis.client.model.MessagesGetMessageSeenStatusResponse;
import com.konfigthis.client.model.MessagesReceiveCustomMessageResponse;
import com.konfigthis.client.model.OutboundMessage;
import com.konfigthis.client.model.OutboundMessageOptions;
import com.konfigthis.client.model.OutboundReplyMessage;
import com.konfigthis.client.model.OutboundReplyMessageOptions;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class MessagesApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MessagesApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public MessagesApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createMessageReplyCall(String conversationId, OutboundReplyMessage outboundReplyMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = outboundReplyMessage;

        // create path and map variables
        String localVarPath = "/conversations/{conversation_id}/messages"
            .replace("{" + "conversation_id" + "}", localVarApiClient.escapeString(conversationId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createMessageReplyValidateBeforeCall(String conversationId, OutboundReplyMessage outboundReplyMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'conversationId' is set
        if (conversationId == null) {
            throw new ApiException("Missing the required parameter 'conversationId' when calling createMessageReply(Async)");
        }

        return createMessageReplyCall(conversationId, outboundReplyMessage, _callback);

    }


    private ApiResponse<Object> createMessageReplyWithHttpInfo(String conversationId, OutboundReplyMessage outboundReplyMessage) throws ApiException {
        okhttp3.Call localVarCall = createMessageReplyValidateBeforeCall(conversationId, outboundReplyMessage, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createMessageReplyAsync(String conversationId, OutboundReplyMessage outboundReplyMessage, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = createMessageReplyValidateBeforeCall(conversationId, outboundReplyMessage, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateMessageReplyRequestBuilder {
        private final String body;
        private final String conversationId;
        private List<String> to;
        private List<String> cc;
        private List<String> bcc;
        private String senderName;
        private String subject;
        private String authorId;
        private String channelId;
        private String text;
        private String quoteBody;
        private OutboundReplyMessageOptions options;
        private List<File> attachments;
        private String signatureId;
        private Boolean shouldAddDefaultSignature;

        private CreateMessageReplyRequestBuilder(String body, String conversationId) {
            this.body = body;
            this.conversationId = conversationId;
        }

        /**
         * Set to
         * @param to List of the recipient handles who will receive this message (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder to(List<String> to) {
            this.to = to;
            return this;
        }
        
        /**
         * Set cc
         * @param cc List of the recipient handles who will receive a copy of this message (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder cc(List<String> cc) {
            this.cc = cc;
            return this;
        }
        
        /**
         * Set bcc
         * @param bcc List of the recipient handles who will receive a copy of this message (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder bcc(List<String> bcc) {
            this.bcc = bcc;
            return this;
        }
        
        /**
         * Set senderName
         * @param senderName Name used for the sender info of the message (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder senderName(String senderName) {
            this.senderName = senderName;
            return this;
        }
        
        /**
         * Set subject
         * @param subject Subject of the message for email message (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder subject(String subject) {
            this.subject = subject;
            return this;
        }
        
        /**
         * Set authorId
         * @param authorId ID of the teammate on behalf of whom the answer is sent (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder authorId(String authorId) {
            this.authorId = authorId;
            return this;
        }
        
        /**
         * Set channelId
         * @param channelId Channel ID the message is sent from (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder channelId(String channelId) {
            this.channelId = channelId;
            return this;
        }
        
        /**
         * Set text
         * @param text Text version of the body for email messages (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder text(String text) {
            this.text = text;
            return this;
        }
        
        /**
         * Set quoteBody
         * @param quoteBody Body for the quote that the message is referencing. Only available on email channels. (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder quoteBody(String quoteBody) {
            this.quoteBody = quoteBody;
            return this;
        }
        
        /**
         * Set options
         * @param options  (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder options(OutboundReplyMessageOptions options) {
            this.options = options;
            return this;
        }
        
        /**
         * Set attachments
         * @param attachments Binary data of attached files. Must use &#x60;Content-Type: multipart/form-data&#x60; if specified. See [example](https://gist.github.com/hdornier/e04d04921032e98271f46ff8a539a4cb) or read more about [Attachments](https://dev.frontapp.com/docs/attachments-1).  Max 25 MB. (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder attachments(List<File> attachments) {
            this.attachments = attachments;
            return this;
        }
        
        /**
         * Set signatureId
         * @param signatureId ID of the signature to attach to this draft. If null, no signature is attached. (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder signatureId(String signatureId) {
            this.signatureId = signatureId;
            return this;
        }
        
        /**
         * Set shouldAddDefaultSignature
         * @param shouldAddDefaultSignature Whether or not Front should try to resolve a signature for the message. Is ignored if signature_id is included. Default false; (optional)
         * @return CreateMessageReplyRequestBuilder
         */
        public CreateMessageReplyRequestBuilder shouldAddDefaultSignature(Boolean shouldAddDefaultSignature) {
            this.shouldAddDefaultSignature = shouldAddDefaultSignature;
            return this;
        }
        
        /**
         * Build call for createMessageReply
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OutboundReplyMessage outboundReplyMessage = buildBodyParams();
            return createMessageReplyCall(conversationId, outboundReplyMessage, _callback);
        }

        private OutboundReplyMessage buildBodyParams() {
            OutboundReplyMessage outboundReplyMessage = new OutboundReplyMessage();
            outboundReplyMessage.to(this.to);
            outboundReplyMessage.cc(this.cc);
            outboundReplyMessage.bcc(this.bcc);
            outboundReplyMessage.senderName(this.senderName);
            outboundReplyMessage.subject(this.subject);
            outboundReplyMessage.authorId(this.authorId);
            outboundReplyMessage.channelId(this.channelId);
            outboundReplyMessage.body(this.body);
            outboundReplyMessage.text(this.text);
            outboundReplyMessage.quoteBody(this.quoteBody);
            outboundReplyMessage.options(this.options);
            outboundReplyMessage.attachments(this.attachments);
            outboundReplyMessage.signatureId(this.signatureId);
            outboundReplyMessage.shouldAddDefaultSignature(this.shouldAddDefaultSignature);
            return outboundReplyMessage;
        }

        /**
         * Execute createMessageReply request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            OutboundReplyMessage outboundReplyMessage = buildBodyParams();
            ApiResponse<Object> localVarResp = createMessageReplyWithHttpInfo(conversationId, outboundReplyMessage);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createMessageReply request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            OutboundReplyMessage outboundReplyMessage = buildBodyParams();
            return createMessageReplyWithHttpInfo(conversationId, outboundReplyMessage);
        }

        /**
         * Execute createMessageReply request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            OutboundReplyMessage outboundReplyMessage = buildBodyParams();
            return createMessageReplyAsync(conversationId, outboundReplyMessage, _callback);
        }
    }

    /**
     * Create message reply
     * Reply to a conversation by sending a message and appending it to the conversation.
     * @param conversationId The conversation ID (required)
     * @return CreateMessageReplyRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
     </table>
     */
    public CreateMessageReplyRequestBuilder createMessageReply(String body, String conversationId) throws IllegalArgumentException {
        if (body == null) throw new IllegalArgumentException("\"body\" is required but got null");
            

        if (conversationId == null) throw new IllegalArgumentException("\"conversationId\" is required but got null");
            

        return new CreateMessageReplyRequestBuilder(body, conversationId);
    }
    private okhttp3.Call createNewMessageCall(String channelId, OutboundMessage outboundMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = outboundMessage;

        // create path and map variables
        String localVarPath = "/channels/{channel_id}/messages"
            .replace("{" + "channel_id" + "}", localVarApiClient.escapeString(channelId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createNewMessageValidateBeforeCall(String channelId, OutboundMessage outboundMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'channelId' is set
        if (channelId == null) {
            throw new ApiException("Missing the required parameter 'channelId' when calling createNewMessage(Async)");
        }

        return createNewMessageCall(channelId, outboundMessage, _callback);

    }


    private ApiResponse<Object> createNewMessageWithHttpInfo(String channelId, OutboundMessage outboundMessage) throws ApiException {
        okhttp3.Call localVarCall = createNewMessageValidateBeforeCall(channelId, outboundMessage, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createNewMessageAsync(String channelId, OutboundMessage outboundMessage, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = createNewMessageValidateBeforeCall(channelId, outboundMessage, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateNewMessageRequestBuilder {
        private final List<String> to;
        private final String body;
        private final String channelId;
        private List<String> cc;
        private List<String> bcc;
        private String senderName;
        private String subject;
        private String authorId;
        private String text;
        private OutboundMessageOptions options;
        private List<File> attachments;
        private String signatureId;
        private Boolean shouldAddDefaultSignature;

        private CreateNewMessageRequestBuilder(List<String> to, String body, String channelId) {
            this.to = to;
            this.body = body;
            this.channelId = channelId;
        }

        /**
         * Set cc
         * @param cc List of the recipient handles who will receive a copy of this message (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder cc(List<String> cc) {
            this.cc = cc;
            return this;
        }
        
        /**
         * Set bcc
         * @param bcc List of the recipient handles who will receive a blind copy of this message (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder bcc(List<String> bcc) {
            this.bcc = bcc;
            return this;
        }
        
        /**
         * Set senderName
         * @param senderName Name used for the sender info of the message (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder senderName(String senderName) {
            this.senderName = senderName;
            return this;
        }
        
        /**
         * Set subject
         * @param subject Subject of the message for email message (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder subject(String subject) {
            this.subject = subject;
            return this;
        }
        
        /**
         * Set authorId
         * @param authorId ID of the teammate on behalf of whom the answer is sent (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder authorId(String authorId) {
            this.authorId = authorId;
            return this;
        }
        
        /**
         * Set text
         * @param text Text version of the body for email messages (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder text(String text) {
            this.text = text;
            return this;
        }
        
        /**
         * Set options
         * @param options  (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder options(OutboundMessageOptions options) {
            this.options = options;
            return this;
        }
        
        /**
         * Set attachments
         * @param attachments Binary data of attached files. Must use &#x60;Content-Type: multipart/form-data&#x60; if specified. See [example](https://gist.github.com/hdornier/e04d04921032e98271f46ff8a539a4cb) or read more about [Attachments](https://dev.frontapp.com/docs/attachments-1). Max 25 MB. (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder attachments(List<File> attachments) {
            this.attachments = attachments;
            return this;
        }
        
        /**
         * Set signatureId
         * @param signatureId ID of the signature to attach to this draft. If null, no signature is attached. (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder signatureId(String signatureId) {
            this.signatureId = signatureId;
            return this;
        }
        
        /**
         * Set shouldAddDefaultSignature
         * @param shouldAddDefaultSignature Whether or not Front should try to resolve a signature for the message. Is ignored if signature_id is included. Default false; (optional)
         * @return CreateNewMessageRequestBuilder
         */
        public CreateNewMessageRequestBuilder shouldAddDefaultSignature(Boolean shouldAddDefaultSignature) {
            this.shouldAddDefaultSignature = shouldAddDefaultSignature;
            return this;
        }
        
        /**
         * Build call for createNewMessage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            OutboundMessage outboundMessage = buildBodyParams();
            return createNewMessageCall(channelId, outboundMessage, _callback);
        }

        private OutboundMessage buildBodyParams() {
            OutboundMessage outboundMessage = new OutboundMessage();
            outboundMessage.to(this.to);
            outboundMessage.cc(this.cc);
            outboundMessage.bcc(this.bcc);
            outboundMessage.senderName(this.senderName);
            outboundMessage.subject(this.subject);
            outboundMessage.authorId(this.authorId);
            outboundMessage.body(this.body);
            outboundMessage.text(this.text);
            outboundMessage.options(this.options);
            outboundMessage.attachments(this.attachments);
            outboundMessage.signatureId(this.signatureId);
            outboundMessage.shouldAddDefaultSignature(this.shouldAddDefaultSignature);
            return outboundMessage;
        }

        /**
         * Execute createNewMessage request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            OutboundMessage outboundMessage = buildBodyParams();
            ApiResponse<Object> localVarResp = createNewMessageWithHttpInfo(channelId, outboundMessage);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute createNewMessage request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            OutboundMessage outboundMessage = buildBodyParams();
            return createNewMessageWithHttpInfo(channelId, outboundMessage);
        }

        /**
         * Execute createNewMessage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            OutboundMessage outboundMessage = buildBodyParams();
            return createNewMessageAsync(channelId, outboundMessage, _callback);
        }
    }

    /**
     * Create message
     * Send a new message from a channel. This is one of the ways to create a new [conversation](https://dev.frontapp.com/reference/conversations#creating-a-new-conversation). The new conversation will support both messages and comments (discussions).
     * @param channelId The sending channel ID. Alternatively, you can supply the sending channel address as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1). (required)
     * @return CreateNewMessageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> A message </td><td>  -  </td></tr>
     </table>
     */
    public CreateNewMessageRequestBuilder createNewMessage(List<String> to, String body, String channelId) throws IllegalArgumentException {
        if (to == null) throw new IllegalArgumentException("\"to\" is required but got null");
        if (body == null) throw new IllegalArgumentException("\"body\" is required but got null");
            

        if (channelId == null) throw new IllegalArgumentException("\"channelId\" is required but got null");
            

        return new CreateNewMessageRequestBuilder(to, body, channelId);
    }
    private okhttp3.Call getMessageByIdCall(String messageId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/{message_id}"
            .replace("{" + "message_id" + "}", localVarApiClient.escapeString(messageId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMessageByIdValidateBeforeCall(String messageId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageId' is set
        if (messageId == null) {
            throw new ApiException("Missing the required parameter 'messageId' when calling getMessageById(Async)");
        }

        return getMessageByIdCall(messageId, _callback);

    }


    private ApiResponse<Object> getMessageByIdWithHttpInfo(String messageId) throws ApiException {
        okhttp3.Call localVarCall = getMessageByIdValidateBeforeCall(messageId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getMessageByIdAsync(String messageId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMessageByIdValidateBeforeCall(messageId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetMessageByIdRequestBuilder {
        private final String messageId;

        private GetMessageByIdRequestBuilder(String messageId) {
            this.messageId = messageId;
        }

        /**
         * Build call for getMessageById
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getMessageByIdCall(messageId, _callback);
        }


        /**
         * Execute getMessageById request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = getMessageByIdWithHttpInfo(messageId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getMessageById request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return getMessageByIdWithHttpInfo(messageId);
        }

        /**
         * Execute getMessageById request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> A message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return getMessageByIdAsync(messageId, _callback);
        }
    }

    /**
     * Get message
     * Fetch a message.  &gt; ℹ️ The HTTP Header &#x60;Accept&#x60; can be used to request the message in a different format. &gt; By default, Front will return the documented JSON response. By requesting &#x60;message/rfc822&#x60;, the response will contain the message in the EML format (for email messages only). 
     * @param messageId The message ID (required)
     * @return GetMessageByIdRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A message </td><td>  -  </td></tr>
     </table>
     */
    public GetMessageByIdRequestBuilder getMessageById(String messageId) throws IllegalArgumentException {
        if (messageId == null) throw new IllegalArgumentException("\"messageId\" is required but got null");
            

        return new GetMessageByIdRequestBuilder(messageId);
    }
    private okhttp3.Call getMessageSeenStatusCall(String messageId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/messages/{message_id}/seen"
            .replace("{" + "message_id" + "}", localVarApiClient.escapeString(messageId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMessageSeenStatusValidateBeforeCall(String messageId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageId' is set
        if (messageId == null) {
            throw new ApiException("Missing the required parameter 'messageId' when calling getMessageSeenStatus(Async)");
        }

        return getMessageSeenStatusCall(messageId, _callback);

    }


    private ApiResponse<MessagesGetMessageSeenStatusResponse> getMessageSeenStatusWithHttpInfo(String messageId) throws ApiException {
        okhttp3.Call localVarCall = getMessageSeenStatusValidateBeforeCall(messageId, null);
        Type localVarReturnType = new TypeToken<MessagesGetMessageSeenStatusResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getMessageSeenStatusAsync(String messageId, final ApiCallback<MessagesGetMessageSeenStatusResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMessageSeenStatusValidateBeforeCall(messageId, _callback);
        Type localVarReturnType = new TypeToken<MessagesGetMessageSeenStatusResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetMessageSeenStatusRequestBuilder {
        private final String messageId;

        private GetMessageSeenStatusRequestBuilder(String messageId) {
            this.messageId = messageId;
        }

        /**
         * Build call for getMessageSeenStatus
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of seen receipts </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getMessageSeenStatusCall(messageId, _callback);
        }


        /**
         * Execute getMessageSeenStatus request
         * @return MessagesGetMessageSeenStatusResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of seen receipts </td><td>  -  </td></tr>
         </table>
         */
        public MessagesGetMessageSeenStatusResponse execute() throws ApiException {
            ApiResponse<MessagesGetMessageSeenStatusResponse> localVarResp = getMessageSeenStatusWithHttpInfo(messageId);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getMessageSeenStatus request with HTTP info returned
         * @return ApiResponse&lt;MessagesGetMessageSeenStatusResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of seen receipts </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MessagesGetMessageSeenStatusResponse> executeWithHttpInfo() throws ApiException {
            return getMessageSeenStatusWithHttpInfo(messageId);
        }

        /**
         * Execute getMessageSeenStatus request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Array of seen receipts </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MessagesGetMessageSeenStatusResponse> _callback) throws ApiException {
            return getMessageSeenStatusAsync(messageId, _callback);
        }
    }

    /**
     * Get message seen status
     * Get the seen receipts for the given message. If no seen-by information is available, there will be a single entry for the first time the message was seen by any recipient. If seen-by information is available, there will be an entry for each recipient who has seen the message.
     * @param messageId The message ID (required)
     * @return GetMessageSeenStatusRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Array of seen receipts </td><td>  -  </td></tr>
     </table>
     */
    public GetMessageSeenStatusRequestBuilder getMessageSeenStatus(String messageId) throws IllegalArgumentException {
        if (messageId == null) throw new IllegalArgumentException("\"messageId\" is required but got null");
            

        return new GetMessageSeenStatusRequestBuilder(messageId);
    }
    private okhttp3.Call importNewInboxMessageCall(String inboxId, ImportMessage importMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importMessage;

        // create path and map variables
        String localVarPath = "/inboxes/{inbox_id}/imported_messages"
            .replace("{" + "inbox_id" + "}", localVarApiClient.escapeString(inboxId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call importNewInboxMessageValidateBeforeCall(String inboxId, ImportMessage importMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'inboxId' is set
        if (inboxId == null) {
            throw new ApiException("Missing the required parameter 'inboxId' when calling importNewInboxMessage(Async)");
        }

        return importNewInboxMessageCall(inboxId, importMessage, _callback);

    }


    private ApiResponse<MessagesReceiveCustomMessageResponse> importNewInboxMessageWithHttpInfo(String inboxId, ImportMessage importMessage) throws ApiException {
        okhttp3.Call localVarCall = importNewInboxMessageValidateBeforeCall(inboxId, importMessage, null);
        Type localVarReturnType = new TypeToken<MessagesReceiveCustomMessageResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call importNewInboxMessageAsync(String inboxId, ImportMessage importMessage, final ApiCallback<MessagesReceiveCustomMessageResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = importNewInboxMessageValidateBeforeCall(inboxId, importMessage, _callback);
        Type localVarReturnType = new TypeToken<MessagesReceiveCustomMessageResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ImportNewInboxMessageRequestBuilder {
        private final ImportMessageSender sender;
        private final List<String> to;
        private final String body;
        private final String externalId;
        private final Integer createdAt;
        private final ImportMessageMetadata metadata;
        private final String inboxId;
        private List<String> tags;
        private List<String> cc;
        private List<String> bcc;
        private String subject;
        private String bodyFormat;
        private String type;
        private String assigneeId;
        private String conversationId;
        private List<File> attachments;

        private ImportNewInboxMessageRequestBuilder(ImportMessageSender sender, List<String> to, String body, String externalId, Integer createdAt, ImportMessageMetadata metadata, String inboxId) {
            this.sender = sender;
            this.to = to;
            this.body = body;
            this.externalId = externalId;
            this.createdAt = createdAt;
            this.metadata = metadata;
            this.inboxId = inboxId;
        }

        /**
         * Set tags
         * @param tags List of tag names to add to the conversation (optional)
         * @return ImportNewInboxMessageRequestBuilder
         */
        public ImportNewInboxMessageRequestBuilder tags(List<String> tags) {
            this.tags = tags;
            return this;
        }
        
        /**
         * Set cc
         * @param cc List of the recipient handles who will receive a copy of this message (optional)
         * @return ImportNewInboxMessageRequestBuilder
         */
        public ImportNewInboxMessageRequestBuilder cc(List<String> cc) {
            this.cc = cc;
            return this;
        }
        
        /**
         * Set bcc
         * @param bcc List of the recipient handles who will receive a blind copy of this message (optional)
         * @return ImportNewInboxMessageRequestBuilder
         */
        public ImportNewInboxMessageRequestBuilder bcc(List<String> bcc) {
            this.bcc = bcc;
            return this;
        }
        
        /**
         * Set subject
         * @param subject Subject of the message (optional)
         * @return ImportNewInboxMessageRequestBuilder
         */
        public ImportNewInboxMessageRequestBuilder subject(String subject) {
            this.subject = subject;
            return this;
        }
        
        /**
         * Set bodyFormat
         * @param bodyFormat Format of the message body. Can be &#x60;markdown&#x60; (default) or &#x60;html&#x60;, and can only be specified for &#x60;email&#x60; type. (optional, default to markdown)
         * @return ImportNewInboxMessageRequestBuilder
         */
        public ImportNewInboxMessageRequestBuilder bodyFormat(String bodyFormat) {
            this.bodyFormat = bodyFormat;
            return this;
        }
        
        /**
         * Set type
         * @param type Type of the message to import. Default is &#x60;email&#x60;. (optional, default to email)
         * @return ImportNewInboxMessageRequestBuilder
         */
        public ImportNewInboxMessageRequestBuilder type(String type) {
            this.type = type;
            return this;
        }
        
        /**
         * Set assigneeId
         * @param assigneeId ID of the teammate who will be assigned to the conversation. (optional)
         * @return ImportNewInboxMessageRequestBuilder
         */
        public ImportNewInboxMessageRequestBuilder assigneeId(String assigneeId) {
            this.assigneeId = assigneeId;
            return this;
        }
        
        /**
         * Set conversationId
         * @param conversationId If supplied, Front will thread this message into conversation with the given ID. Note that including this parameter nullifies the &#x60;thread_ref&#x60; parameter _completely_. (optional)
         * @return ImportNewInboxMessageRequestBuilder
         */
        public ImportNewInboxMessageRequestBuilder conversationId(String conversationId) {
            this.conversationId = conversationId;
            return this;
        }
        
        /**
         * Set attachments
         * @param attachments Binary data of attached files. Must use &#x60;Content-Type: multipart/form-data&#x60; if specified. See [example](https://gist.github.com/hdornier/e04d04921032e98271f46ff8a539a4cb) or read more about [Attachments](https://dev.frontapp.com/docs/attachments-1).  Max 25 MB. (optional)
         * @return ImportNewInboxMessageRequestBuilder
         */
        public ImportNewInboxMessageRequestBuilder attachments(List<File> attachments) {
            this.attachments = attachments;
            return this;
        }
        
        /**
         * Build call for importNewInboxMessage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ImportMessage importMessage = buildBodyParams();
            return importNewInboxMessageCall(inboxId, importMessage, _callback);
        }

        private ImportMessage buildBodyParams() {
            ImportMessage importMessage = new ImportMessage();
            importMessage.tags(this.tags);
            importMessage.sender(this.sender);
            importMessage.to(this.to);
            importMessage.cc(this.cc);
            importMessage.bcc(this.bcc);
            importMessage.subject(this.subject);
            importMessage.body(this.body);
            if (this.bodyFormat != null)
            importMessage.bodyFormat(ImportMessage.BodyFormatEnum.fromValue(this.bodyFormat));
            importMessage.externalId(this.externalId);
            importMessage.createdAt(this.createdAt);
            if (this.type != null)
            importMessage.type(ImportMessage.TypeEnum.fromValue(this.type));
            importMessage.assigneeId(this.assigneeId);
            importMessage.conversationId(this.conversationId);
            importMessage.metadata(this.metadata);
            importMessage.attachments(this.attachments);
            return importMessage;
        }

        /**
         * Execute importNewInboxMessage request
         * @return MessagesReceiveCustomMessageResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
         </table>
         */
        public MessagesReceiveCustomMessageResponse execute() throws ApiException {
            ImportMessage importMessage = buildBodyParams();
            ApiResponse<MessagesReceiveCustomMessageResponse> localVarResp = importNewInboxMessageWithHttpInfo(inboxId, importMessage);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute importNewInboxMessage request with HTTP info returned
         * @return ApiResponse&lt;MessagesReceiveCustomMessageResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MessagesReceiveCustomMessageResponse> executeWithHttpInfo() throws ApiException {
            ImportMessage importMessage = buildBodyParams();
            return importNewInboxMessageWithHttpInfo(inboxId, importMessage);
        }

        /**
         * Execute importNewInboxMessage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MessagesReceiveCustomMessageResponse> _callback) throws ApiException {
            ImportMessage importMessage = buildBodyParams();
            return importNewInboxMessageAsync(inboxId, importMessage, _callback);
        }
    }

    /**
     * Import message
     * Import a new message in an inbox.
     * @param inboxId The Inbox ID (required)
     * @return ImportNewInboxMessageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
     </table>
     */
    public ImportNewInboxMessageRequestBuilder importNewInboxMessage(ImportMessageSender sender, List<String> to, String body, String externalId, Integer createdAt, ImportMessageMetadata metadata, String inboxId) throws IllegalArgumentException {
        if (sender == null) throw new IllegalArgumentException("\"sender\" is required but got null");
        if (to == null) throw new IllegalArgumentException("\"to\" is required but got null");
        if (body == null) throw new IllegalArgumentException("\"body\" is required but got null");
            

        if (externalId == null) throw new IllegalArgumentException("\"externalId\" is required but got null");
            

        if (createdAt == null) throw new IllegalArgumentException("\"createdAt\" is required but got null");
        if (metadata == null) throw new IllegalArgumentException("\"metadata\" is required but got null");
        if (inboxId == null) throw new IllegalArgumentException("\"inboxId\" is required but got null");
            

        return new ImportNewInboxMessageRequestBuilder(sender, to, body, externalId, createdAt, metadata, inboxId);
    }
    private okhttp3.Call markMessageSeenCall(String messageId, Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/messages/{message_id}/seen"
            .replace("{" + "message_id" + "}", localVarApiClient.escapeString(messageId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call markMessageSeenValidateBeforeCall(String messageId, Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'messageId' is set
        if (messageId == null) {
            throw new ApiException("Missing the required parameter 'messageId' when calling markMessageSeen(Async)");
        }

        return markMessageSeenCall(messageId, body, _callback);

    }


    private ApiResponse<Void> markMessageSeenWithHttpInfo(String messageId, Object body) throws ApiException {
        okhttp3.Call localVarCall = markMessageSeenValidateBeforeCall(messageId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call markMessageSeenAsync(String messageId, Object body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = markMessageSeenValidateBeforeCall(messageId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class MarkMessageSeenRequestBuilder {
        private final String messageId;

        private MarkMessageSeenRequestBuilder(String messageId) {
            this.messageId = messageId;
        }

        /**
         * Build call for markMessageSeen
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            Object body = buildBodyParams();
            return markMessageSeenCall(messageId, body, _callback);
        }

        private Object buildBodyParams() {
            Object body = new Object();
            return body;
        }

        /**
         * Execute markMessageSeen request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            Object body = buildBodyParams();
            markMessageSeenWithHttpInfo(messageId, body);
        }

        /**
         * Execute markMessageSeen request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            Object body = buildBodyParams();
            return markMessageSeenWithHttpInfo(messageId, body);
        }

        /**
         * Execute markMessageSeen request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            Object body = buildBodyParams();
            return markMessageSeenAsync(messageId, body, _callback);
        }
    }

    /**
     * Mark message seen
     * Mark an outbound message from Front as seen. Note, the message seen route should only be called in response to an actual end-user&#39;s message-seen action. In accordance with this behavior, the route is rate limited to 10 requests per hour. The request body should send an empty object.
     * @param messageId The message ID (required)
     * @return MarkMessageSeenRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No content </td><td>  -  </td></tr>
     </table>
     */
    public MarkMessageSeenRequestBuilder markMessageSeen(String messageId) throws IllegalArgumentException {
        if (messageId == null) throw new IllegalArgumentException("\"messageId\" is required but got null");
            

        return new MarkMessageSeenRequestBuilder(messageId);
    }
    private okhttp3.Call receiveCustomMessageCall(String channelId, CustomMessage customMessage, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = customMessage;

        // create path and map variables
        String localVarPath = "/channels/{channel_id}/incoming_messages"
            .replace("{" + "channel_id" + "}", localVarApiClient.escapeString(channelId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "http" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call receiveCustomMessageValidateBeforeCall(String channelId, CustomMessage customMessage, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'channelId' is set
        if (channelId == null) {
            throw new ApiException("Missing the required parameter 'channelId' when calling receiveCustomMessage(Async)");
        }

        return receiveCustomMessageCall(channelId, customMessage, _callback);

    }


    private ApiResponse<MessagesReceiveCustomMessageResponse> receiveCustomMessageWithHttpInfo(String channelId, CustomMessage customMessage) throws ApiException {
        okhttp3.Call localVarCall = receiveCustomMessageValidateBeforeCall(channelId, customMessage, null);
        Type localVarReturnType = new TypeToken<MessagesReceiveCustomMessageResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call receiveCustomMessageAsync(String channelId, CustomMessage customMessage, final ApiCallback<MessagesReceiveCustomMessageResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = receiveCustomMessageValidateBeforeCall(channelId, customMessage, _callback);
        Type localVarReturnType = new TypeToken<MessagesReceiveCustomMessageResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ReceiveCustomMessageRequestBuilder {
        private final CustomMessageSender sender;
        private final String body;
        private final String channelId;
        private String subject;
        private String bodyFormat;
        private CustomMessageMetadata metadata;
        private List<File> attachments;

        private ReceiveCustomMessageRequestBuilder(CustomMessageSender sender, String body, String channelId) {
            this.sender = sender;
            this.body = body;
            this.channelId = channelId;
        }

        /**
         * Set subject
         * @param subject Subject of the message (optional)
         * @return ReceiveCustomMessageRequestBuilder
         */
        public ReceiveCustomMessageRequestBuilder subject(String subject) {
            this.subject = subject;
            return this;
        }
        
        /**
         * Set bodyFormat
         * @param bodyFormat Format of the message body. Can be &#x60;markdown&#x60; (default) or &#x60;html&#x60;. (optional, default to markdown)
         * @return ReceiveCustomMessageRequestBuilder
         */
        public ReceiveCustomMessageRequestBuilder bodyFormat(String bodyFormat) {
            this.bodyFormat = bodyFormat;
            return this;
        }
        
        /**
         * Set metadata
         * @param metadata  (optional)
         * @return ReceiveCustomMessageRequestBuilder
         */
        public ReceiveCustomMessageRequestBuilder metadata(CustomMessageMetadata metadata) {
            this.metadata = metadata;
            return this;
        }
        
        /**
         * Set attachments
         * @param attachments Binary data of attached files. Must use &#x60;Content-Type: multipart/form-data&#x60; if specified. See [example](https://gist.github.com/hdornier/e04d04921032e98271f46ff8a539a4cb) or read more about [Attachments](https://dev.frontapp.com/docs/attachments-1).  Max 25 MB. (optional)
         * @return ReceiveCustomMessageRequestBuilder
         */
        public ReceiveCustomMessageRequestBuilder attachments(List<File> attachments) {
            this.attachments = attachments;
            return this;
        }
        
        /**
         * Build call for receiveCustomMessage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            CustomMessage customMessage = buildBodyParams();
            return receiveCustomMessageCall(channelId, customMessage, _callback);
        }

        private CustomMessage buildBodyParams() {
            CustomMessage customMessage = new CustomMessage();
            customMessage.sender(this.sender);
            customMessage.subject(this.subject);
            customMessage.body(this.body);
            if (this.bodyFormat != null)
            customMessage.bodyFormat(CustomMessage.BodyFormatEnum.fromValue(this.bodyFormat));
            customMessage.metadata(this.metadata);
            customMessage.attachments(this.attachments);
            return customMessage;
        }

        /**
         * Execute receiveCustomMessage request
         * @return MessagesReceiveCustomMessageResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
         </table>
         */
        public MessagesReceiveCustomMessageResponse execute() throws ApiException {
            CustomMessage customMessage = buildBodyParams();
            ApiResponse<MessagesReceiveCustomMessageResponse> localVarResp = receiveCustomMessageWithHttpInfo(channelId, customMessage);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute receiveCustomMessage request with HTTP info returned
         * @return ApiResponse&lt;MessagesReceiveCustomMessageResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MessagesReceiveCustomMessageResponse> executeWithHttpInfo() throws ApiException {
            CustomMessage customMessage = buildBodyParams();
            return receiveCustomMessageWithHttpInfo(channelId, customMessage);
        }

        /**
         * Execute receiveCustomMessage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MessagesReceiveCustomMessageResponse> _callback) throws ApiException {
            CustomMessage customMessage = buildBodyParams();
            return receiveCustomMessageAsync(channelId, customMessage, _callback);
        }
    }

    /**
     * Receive custom messages
     * Receive a custom message in Front. This endpoint is available for custom channels **ONLY**.
     * @param channelId The channel ID. Alternatively, you can supply the channel address as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1). (required)
     * @return ReceiveCustomMessageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> An accepted message </td><td>  -  </td></tr>
     </table>
     */
    public ReceiveCustomMessageRequestBuilder receiveCustomMessage(CustomMessageSender sender, String body, String channelId) throws IllegalArgumentException {
        if (sender == null) throw new IllegalArgumentException("\"sender\" is required but got null");
        if (body == null) throw new IllegalArgumentException("\"body\" is required but got null");
            

        if (channelId == null) throw new IllegalArgumentException("\"channelId\" is required but got null");
            

        return new ReceiveCustomMessageRequestBuilder(sender, body, channelId);
    }
}
